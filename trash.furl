___ := ___;
__# := _%%;
_#_ := %%_;
_## := %%%;
#__ := %__;
#_# := %%%;
### := %_%;

(
	3230420 244903094 4340990 := 32;
	0x1234234 := fads;
	fads = 323;

	SSO + SSSO == SSSSSO;
	SSO + SSSO :: SSSSSO;
	0 + SS0 =: SS0;

	nfurl would operate on bytes like normal furl, but they are inputted
	as numbers, instead of as strings. The restriction of non-whitespace ascii
	would no longer apply. (should this be furl8 or nf8?)

	xfurl would operate on 64-bit number ID's, and it would be
	the one to use for serious pure computation. (should this be furl64 or nf64?)

	Bot nfurl and xfurl would have a few extra syntactic sugar operators:
	name = value;
	query/file/path.nq: (only for nfurl, loaded as []u8)
	query/file/path.xq: (only for xfurl, loaded as []64)
	The last two load a file as the query, with no parsing. Can also be loaded from the CLI.
	Finally, .q would be loaded for ascii unfurl, and only from the CLI.

	I have more sugar ideas:
	10, 20 := 30, 40;
	would be sugar for:
	10 := 30;
	10 := 40;
	20 := 30;
	30 := 40;

	But the main feature:
	3242 :: 1212, 2121;
	instead of:
	3242 :: 1212;
	3242 :: 2121;
)
