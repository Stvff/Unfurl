___ := ___;
__# := _%%;
_#_ := %%_;
_## := %%%;
#__ := %__;
#_# := %%%;
### := %_%;

(
	3230420 244903094 4340990 := 32;
	0x1234234 := fads;
	fads = 323; (error: fads was already used and has therefore already gotten a value)

	SSO + SSSO == SSSSSO;
	SSO + SSSO :: SSSSSO;
	0 + SS0 =: SS0;

	nfurl would operate on bytes like normal furl, but they are inputted
	as numbers, instead of as strings. The restriction of non-whitespace ascii
	would no longer apply. (should this be furl8 or nf8?)

	xfurl would operate on 64-bit number ID's, and it would be
	the one to use for serious pure computation. (should this be furl64 or nf64?)

	Bot nfurl and xfurl would have a few extra syntactic sugar operators:
	name = value;
	query/file/path.nq: (only for nfurl, loaded as []u8)
	query/file/path.xq: (only for xfurl, loaded as []64)
	The last two load a file as the query, with no parsing. Can also be loaded from the CLI.
	Finally, .q would be loaded for ascii unfurl, and only from the CLI.

	I have more sugar ideas:
	10, 20 := 30, 40;
	would be sugar for:
	10 := 30;
	10 := 40;
	20 := 30;
	30 := 40;

	But the main feature:
	3242 :: 1212, 2121;
	instead of:
	3242 :: 1212;
	3242 :: 2121;

	arg charset length = 2; acl
	res charset length = 4; rcl
	max arg length = 10; mal
	max res length = 10; mrl
	max rule count = 4;  mc

	{1} := {1}, {1} := {2}, {1} := {3}, {1} := {4}, ..., {1} := {mrl}
	{2} := {1}, {2} := {2}, {2} := {3}, {2} := {4}, ...
	{3} := {1}, {3} := {2}, {3} := {3}, {3} := {4}, ...
	{4} := {1}, {4} := {2}, {4} := {3}, {4} := {4}, ...
	...
	{mal} := {1}, {mal} := {2}, ...,   {mal} := {mrl}

	{n} := {m}; is a certain amount of rules:
	; acl^n * rcl^m

	; Some Uiua code:
Acl ← 2
Rcl ← 4
Mal ← 10
Mrl ← 10
Mc  ← 4
SingleRulePermutations ← × ⁿ:Rcl: ⁿ:Acl
SingleRulePermutations 3 2 # This shows the amount of rules that {3} := {2} is
AllSingleRulePermutations = /+ ≡SingleRulePermutations °couple trans reshape couple:2 ÷2/×shape. +1range couple
AllSingleRulePermutations Mal Mrl # shows allllll the permutations, but for a single rule
RulePermutations ← /× --1 dip(+range).: AllSingleRulePermutations Mal Mrl
RulePermutations 2 # Gives the amount of possible combinations when you have two rules
AllRulePermutations ← /+≡RulePermutations +1range
AllRulePermutations Mc # Gives all rulesets that need to be checked for completion

	; For our case, this is bad.
	; I'd need a 128 bit value to enumerate them all.
	; And it would barely fit.

	; To find the solution to my example problem, a 64 bit number would just about suffice.
	; I need more serious culling
)
