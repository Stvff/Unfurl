<!doctype html>
<html lang="en-CA">
	<head>
		<meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <meta name="author" content="stvff" />
		<title>Unfurl</title>
		<style>
		* { font-family: 'Noto Serif', serif; background-color: #111111; color: #DDD; }
		pre code { font-family: monospace; background-color: #090909; padding-inline: 15px; }
		.arg{ color: lightgreen; }
		.res{ color: cyan; }
		.syntax{ color: magenta; }
		.query{ color: pink; }
		.result_solved { color: lightblue; }
		.result_interm { color: red; }
		h1,h2,h3,h4 { color: yellow; }
		</style>
	</head>
<body><main>
<h1>1- Unfurl Explanation</h1>
Unfurl is really nothing more than an elaborate substitution machine.<br/>
You input rules:
<pre><code><span class="arg">a</span> <span class="syntax">:=</span> <span class="res">b</span><span class="syntax">;</span>
</code></pre>
And queries:
<pre><code><span class="query">bbb</span><span class="syntax">:</span>
</code></pre>
And the evaluator applies the rules to the queries:
<pre><code><span class="result_solved">aaa</span>
</code></pre>

Interestingly enough, there is an enormous wealth of complexity that can be extracted
from this simple paradigm.<br/>
For example, some rules and inputs have multiple different combinations. The evaluator
always evaluates every single possible combination.<br/>
As an example:
<pre><code><span class="arg">aa</span> <span class="syntax">:=</span> <span class="res">b</span><span class="syntax">;</span>
<span class="query">aaa</span><span class="syntax">:</span>
</code></pre>
Has two possible solutions:
<pre><code><span class="result_solved">ba</span>
<span class="result_solved">ab</span>
</code></pre>
A more elaborate example:
<pre><code><span class="arg">aa</span> <span class="syntax">:=</span> <span class="res">u</span><span class="syntax">;</span>
<span class="arg">aa</span> <span class="syntax">:=</span> <span class="res">v</span><span class="syntax">;</span>
<span class="query">aaa</span><span class="syntax">:</span>
</code></pre>
Results in four possible solutions:
<pre><code><span class="result_solved">ua</span>
<span class="result_solved">au</span>
<span class="result_solved">va</span>
<span class="result_solved">av</span>
</code></pre>

The evaluation continues applying rules until no more changes happen. This has two
implications.
1) Infinite evalution is possible:
<pre><code><span class="arg">n</span> <span class="syntax">:=</span> <span class="res">nn</span><span class="syntax">;</span>
<span class="query">n</span><span class="syntax">:</span>
</code></pre>
2) The rules are applied to 'intermediate' results. This is where most of the real
   useful complexity of Unfurl comes from.<br/>
As a basic example:
<pre><code><span class="arg">N0</span> <span class="syntax">:=</span> <span class="res">1</span><span class="syntax">;</span>
<span class="arg">N1</span> <span class="syntax">:=</span> <span class="res">2</span><span class="syntax">;</span>
<span class="arg">N2</span> <span class="syntax">:=</span> <span class="res">3</span><span class="syntax">;</span>
<span class="query">NNN0</span><span class="syntax">:</span>
</code></pre>
Results in:
<pre><code><span class="result_solved">3</span>
</code></pre>
When running the evaluator with `-all-states`, you can see all the intermediate steps.
<pre><code><span class="result_interm">NNN0</span>, intermediate
<span class="result_interm">NN1</span>, intermediate
<span class="result_interm">N2</span>, intermediate
<span_class="result_solved">3</span>, solved
</code></pre>

<h3>1.1- Writing .furl files (aka my parser is not so smart so don't shake it too much it'll throw up)</h3>
The only valid input is ascii.<br/>
All whitespace is ignored and removed (so spaces will not show up in rules,
queries, or solutions).<br/>
Comments can be placed between parentheses (like so (they can nest)).<br/>
When calling the evaluator on multiple files at once, all their rules and queries are
combined into one larger evaluation pool.

<h2>2- Turing Compleness</h2>
Unfurl is turing complete. The reason why anything is Turing complete is always somewhat
vague, since it comes down to "Can you do the things that a Turing machine can do?"<br/>
The standard way to go about proving this is to provide a method to simulate any Turing
machine, or to simulate something else that can simulate any turing machine.<br/>
In Unfurl's case, both have been done. The latter via an implementation of rule 110, and
the former will be outlined in here. Furthermore, we will look at some important qualities
of Unfurl that make these things possible.

<h3>2.1- Important Qualities of Equivalence</h3>
<h4>2.1.1- The Readhead</h4>
Turing machines sit on a tape and move cell-by-cell. Unfurl evaluates one tape in full, but
in order to apply rules, it subdivides the tape into smaller 'subtapes' to compare against.
In fact, it subdivides in all possible ways, which means that there is always a set of
'subtapes' that _look_ like a 'scanning window' of the full tape: just like the one a Turing
machine sees. Let's take the following rule and query:
<pre><code><span class="arg">a</span> <span class="syntax">:=</span> <span class="res">>A</span><span class="syntax">;</span>
<span class="query">aaa</span><span class="syntax">:</span>
</code></pre>
When we look at the intermediate results, we can see that the first three applications appear
as if there is a readhead going through the tape, capitalizing the letter it looks at.
<pre><code><span class="result_interm">>Aaa</span>, intermediate
<span class="result_interm">a>Aa</span>, intermediate
<span class="result_interm">aa>A</span>, intermediate
...
</code></pre>
Of course, the evaluator continues, because we did not fully constrain it.<br/>
To constrain it, we can include the readhead in the query, as well as including it
in every rule, so that evaluation can only happen wherever the readhead is.
<pre><code><span class="arg">>a</span> <span class="syntax">:=</span> <span class="res">a></span><span class="syntax">;</span>
<span class="query">aaa</span><span class="syntax">:</span>
<span class="result_interm">>aaa</span>, intermediate
<span class="result_interm">a>aa</span>, intermediate
<span class="result_interm">aa>a</span>, intermediate
<span_class="result_solved">aaa></span>, solved
</code></pre>

<h4>2.1.2- The Unbounded Tape</h4>
Turing machines sit on an infinite tape. At least, they are not principially bounded.
Unfurl begins with a finite tape, but there are many possible rulesets that expand the
tape during evaluation, since the length of a rule's result can be larger than its input:
<pre><code><span class="arg">a</span> <span class="syntax">:=</span> <span class="res">bbb</span><span class="syntax">;</span>
<span class="query">aaa</span><span class="syntax">:</span>
<span class="result_solved">bbbbbbbbb</span>
</code></pre>
A good way to make use of this is to have 'end markers' on the tape, and some rules to
expand the tape when required. Using our readhead from the previous section,
we can make an orderly and infinitely expanding tape:
<pre><code><span class="arg">>a</span> <span class="syntax">:=</span> <span class="res">a></span><span class="syntax">;</span>
<span class="arg">>|</span> <span class="syntax">:=</span> <span class="res">>a|</span><span class="syntax">;</span>
<span class="query">>aaa|</span><span class="syntax">:</span>
</code></pre>

<h4>2.1.2- The Internal State</h4>
Finally, Turing machines have internal state. Unfurl does not have this at all.
However, that is not the end of the line; really the important part is the state
of the whole system, tape and 'internal state' (or M-configuration) combined.
This all-encompassing state can be easily transposed onto an Unfurl tape.
The simplest way to do it is to include the M-configuration next to the earlier
defined readhead. In the following example, `1`, `2`, `3`, and `4` are M-configurations.
<pre><code><span class="arg">1> a</span> <span class="syntax">:=</span> <span class="res">a 2></span><span class="syntax">;</span>
<span class="arg">2> a</span> <span class="syntax">:=</span> <span class="res">a 3></span><span class="syntax">;</span>
<span class="arg">3> a</span> <span class="syntax">:=</span> <span class="res">a 4></span><span class="syntax">;</span>
<span class="query">1> aaaaa</span><span class="syntax">:</span>
<span class="result_solved">aaa4>aaa</span>
</code></pre>
A careful reader might notice that the M-configuration can serve as the readhead itself,
but it is good for readability to give an indication of which symbol is currently
'under' the readhead.<br/>
Notably, this most recent example is already a pretty direct transcription of a
Turing machine. Indeed, we now have all the tools to start generalizing.

<h3>2.2- General technique for converting a Turing machine to Unfurl substitution rules</h3>
There is of course more than one way to do this, but the technique layed out here
approaches optimal.<br/>
<h4>2.2.1- Query formatting</h4>
The query can consist of any number of symbols from the alphabet, but should have
'end-markers' on both ends. For example:
<pre><code><span class="query">|001010|</span><span class="syntax">:</span>
</code></pre>
UNFINISHED

<h2>3- What is this good for?</h2>
I wanted to make a really simple language that I could practice
nontrivial multithreading on.<br/>
After I'd made the reference interpreter, I realized that it's really fascinating to
have a single-operator turing complete language, and it's a fun sort of puzzle
activity to play with.

This being said, at some point I would like to make a 'program searcher', that can
find rulesets to solve problems on its own.

</main></body></html>
