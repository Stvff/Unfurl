# Installation
Unfurl is just one executable, `unfurl` (`unfurl.exe` on windows).
It can be downloaded [here](https://github.com/Stvff/Unfurl/releases/latest).\
You may need to give it executable permissions on linux:
```
chmod +x ./unfurl
```
After that, and after adding it to your `PATH` in some way,
you can just run the executable in a terminal and it will tell you what to do.

The executable contains explainers on every subject, under various `-explain` flags.
The rest of this readme consists of those explainers (generated by unfurl itself!),
in case you're not near your computer at the moment.

# 1- Unfurl Explanation
Unfurl is really nothing more than an elaborate substitution machine.\
You input rules:
```
a := b;
```
And queries:
```
bbb:
```
And the evaluator applies the rules to the queries:
```
aaa
```

Interestingly enough, there is an enormous wealth of complexity that can be extracted
from this simple paradigm.\
For example, some rules and inputs have multiple different combinations. The evaluator
always evaluates every single possible combination.\
As an example:
```
aa := b;
aaa:
```
Has two possible solutions:
```
ba
ab
```
A more elaborate example:
```
aa := u;
aa := v;
aaa:
```
Results in four possible solutions:
```
ua
au
va
av
```

The evaluation continues applying rules until no more changes happen. This has two
implications.
1) Infinite evalution is possible:
```
n := nn;
n:
```
2) The rules are applied to 'intermediate' results. This is where most of the real
   useful complexity of Unfurl comes from.\
As a basic example:
```
N0 := 1;
N1 := 2;
N2 := 3;
NNN0:
```
Results in:
```
3
```
When running the evaluator with `-all-states`, you can see all the intermediate steps.
```
NNN0, intermediate
NN1, intermediate
N2, intermediate
3, solved
```

### 1.1- Writing .furl files (aka my parser is not so smart so don't shake it too much it'll throw up)
The only valid input is ascii.\
All whitespace is ignored and removed (so spaces will not show up in rules,
queries, or solutions).\
Comments can be placed between parentheses (like so (they can nest)).\
When calling the evaluator on multiple files at once, all their rules and queries are
combined into one larger evaluation pool.

## 2- Turing Compleness
Unfurl is turing complete. The reason why anything is Turing complete is always somewhat
vague, since it comes down to "Can you do the things that a Turing machine can do?"\
The standard way to go about proving this is to provide a method to simulate any Turing
machine, or to simulate something else that can simulate any turing machine.\
In Unfurl's case, both have been done. The latter via an implementation of rule 110, and
the former will be outlined in here. Furthermore, we will look at some important qualities
of Unfurl that make these things possible.

### 2.1- Important Qualities of Equivalence
#### 2.1.1- The Readhead
Turing machines sit on a tape and move cell-by-cell. Unfurl evaluates one tape in full, but
in order to apply rules, it subdivides the tape into smaller 'subtapes' to compare against.
In fact, it subdivides in all possible ways, which means that there is always a set of
'subtapes' that _look_ like a 'scanning window' of the full tape: just like the one a Turing
machine sees. Let's take the following rule and query:
```
a := >A;
aaa:
```
When we look at the intermediate results, we can see that the first three applications appear
as if there is a readhead going through the tape, capitalizing the letter it looks at.
```
>Aaa, intermediate
a>Aa, intermediate
aa>A, intermediate
...
```
Of course, the evaluator continues, because we did not fully constrain it.\
To constrain it, we can include the readhead in the query, as well as including it
in every rule, so that evaluation can only happen wherever the readhead is.
```
>a := a>;
aaa:
>aaa, intermediate
a>aa, intermediate
aa>a, intermediate
aaa>, solved
```

#### 2.1.2- The Unbounded Tape
Turing machines have infinite tapes. At least, they are not principially bounded.
Unfurl begins with a finite tape, but there are many possible rulesets that expand the
tape during evaluation, since the length of a rule's result can be larger than its input:
```
a := bbb;
aaa:
bbbbbbbbb
```
A good way to make use of this is to have 'end markers' on the tape, and some rules to
expand the tape when required. Using our readhead from the previous section,
we can make an orderly and infinitely expanding tape:
```
>a := a>;
>| := >a|;
>aaa|:
```

#### 2.1.2- The Internal State
Finally, Turing machines have internal state. Unfurl does not have this at all.
However, that is not the end of the line; really the important part is the state
of the whole system, tape and 'internal state' (or M-configuration) combined.
This all-encompassing state can easily be transposed onto an unfurl tape.
The simplest way to do it is to include the M-configuration next to the earlier
defined readhead. In the following example, `1`, `2`, `3`, and `4` are M-configurations.
```
1> a := a 2>;
2> a := a 3>;
3> a := a 4>;
1> aaaaa:
aaa4>aaa
```
A careful reader might notice that the M-configuration can serve as the readhead itself,
but it is good for readability to give an indication of which symbol is currently
'under' the readhead.

### 2.2- General technique for converting a Turing machine to Unfurl substitution rules
There is of course more than one way to do this, but the technique layed out here
approaches optimal.
UNFINISHED

## 3- What is this good for?
I wanted to make a really simple language that I could practice
nontrivial multithreading on.\
After I'd made the reference interpreter, I realized that it's really fascinating to
have a single-operator turing complete language, and it's a fun sort of puzzle
activity to play with.

This being said, at some point I would like to make a 'program searcher', that can
find rulesets to solve problems on its own.

