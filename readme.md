# Installation
Unfurl is just one executable, `unfurl` (`unfurl.exe` on windows).
It can be downloaded [here](https://github.com/Stvff/Unfurl/releases).\
You may need to give it executable permissions on linux:
```
chmod +x ./unfurl
```
After that, and after adding it to your path in some way,
you can just run the executable in a terminal and it will tell you what to do.

The executable contains explainers on every subject, under various `-explain` flags.
The rest of this readme consists of those explainers (generated by unfurl itself!),
in case you're not near your computer at the moment.

# 1- Unfurl Explanation
Unfurl is really nothing more than an elaborate substitution machine.\
You input rules:
```
a := b;
```
And queries:
```
bbb:
```
And the evaluator applies the rule to the queries:
```
aaa
```

Interestingly enough, there is an enormous wealth of complexity that can be extracted
from this simple paradigm.\
For example, some rules and inputs have multiple different combinations. The evaluator
always evaluates every single possible combination.\
As an example:
```
aa := b;
aaa:
```
Has two possible solutions:
```
ba
ab
```
A more elaborate example:
```
aa := u;
aa := v;
aaa:
```
Results in four possible solutions:
```
ua
au
va
av
```

The evaluation continues applying rules until no more changes happen. This has two
implications.
1) Infinite evalution is possible:
```
n := nn;
n:
```
2) The rules are applied to 'intermediate' results. This is where most of the real
   useful complexity of Unfurl comes from.\
As a basic example:
```
N0 := 1;
N1 := 2;
N2 := 3;
NNN0:
```
Results in:
```
3
```
When running the evaluator with -all-states, you can see all the intermediate steps.
```
NNN0, intermediate
NN1, intermediate
N2, intermediate
3, solved
```

### 1.1- Writing .furl files (aka my parser is not so smart so don't shake it too much it'll throw up)
The only valid input is ascii.\
All whitespace is ignored and removed (so spaces will not show up in rules,
queries, or solutions).\
Comments can be placed between parentheses (like so (also they can nest)).\
When calling the evaluator on multiple files at once, all their rules and queries are
combined into one larger evaluation pool.

## 2- Turing Compleness
Unfurl is turing complete. The reason why anything is Turing complete is always somewhat
vague, since it comes down to "Can you do the things that a Turing machine can do?"\
The standard way to go about proving this is to simulate a Turing machine, or to simulate
something else that can simulate a turing machine.\
In Unfurl's case, the latter has been done (via rule 110), and I'll attempt to lay out
a rough guide on how to do the former here, as well as highlight some important
 qualities that make it all possible.

### 2.1- Important Qualities of Equivalence
Turing machines sit on a tape and move cell-by-cell. Unfurl evaluates one tape in full, but
in order to apply rules, it subdivides the tape into smaller 'subtapes' to compare against.
In fact, it subdivides in all possible ways, whichs means that there is always a set of
'subtapes' that _look_ like a 'scanning window' of the full tape: just like the one a Turing
machine sees. We will look at how to leverage this effectively in the next paragraph.

Turing machines have infinite tapes. At least, they are not principially bounded.
Unfurl begins with a finite tape, but there is a large number of rulesets that expand the
tape during evaluation, since the length of a rule's result can be larger than its input:
```
a := bbb;
aaa:
bbbbbbbbb
```
A good way to make use of this is to have 'end markers' on the tape, and some rules to
expand the tape when required.

Finally, Turing machines have internal state. Unfurl does not have this at all.
However, that is not the end of the line; internal state can be translated into
symbols on the tape, and the ruleset adjusted accordingly. More on this later.

### 2.2- Making the Evaluator 'Walk' and Externalizing Internal State
When directly simulating a turing machine, it can be impractical how unfurl evaluates
at all points on the tape at the same time. Indeed, it can lead to
guarenteed 'race conditions'. To mitigate this, there are two prominent strategies.

UNFINISHED

## 3- What is this good for?
I wanted to make a really simple language that I could practice
nontrivial multithreading on.\
After I'd made the reference interpreter, I realized that it's really fascinating to
have a single-operator turing complete language, and it's a fun sort of puzzle
 activity to play with.

This being said, at some point I want to make a 'program searcher', that can find
rulesets to solve problems on its own.

